---
title: "Breed Simulation Testing"
output: pdf_document
date: '2023-10-02'
---

```{r setup, include=FALSE}
knitStartTime <- Sys.time()
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Import packages
suppressPackageStartupMessages({
  library(gaston)
  library(TSP)
  library(breedSimulatR)
  library(digest)
  library(glmnet)
  library(mlrMBO)
  library(parallelMap)
  library(parallel)
  library(lhs)
  library(dotenv)
  library(tidyverse)
  library(plotly)
  library(dplyr)
})
source("src/optimization.R")
source("src/setupSimulation.R")
selMate_env <- new.env(parent = globalenv())
source('src/selectMatFun.R', local = selMate_env)
genoPred_env <- new.env(parent = globalenv())
source('src/genoPred.R', local = genoPred_env)
sim_env <- new.env(parent = globalenv())
source('src/simulation.R')#, local = sim_env)

```

```{r}
load_dot_env()
nCPU <- detectCores()
# nCPU <- 2
nRepOpt <- 1 # number of optimization repetitions
# nRepOpt <- 1024 # number of optimization repetitions
repRes_nRep <- 1 # number of opt result evaluations
repRes_nCpus <- 2 # number of core to use for opt result evaluations

simSetupFolder <- "simSetups"
optSetupFolder <- "optSetups"
optResultFolder <- "output-optimization"
repResultFolder <- "output-resultRepetition"

###
date <- format(knitStartTime, "%Y-%m-%d_%H-%M-%S")
simSetupFolder <- paste0(simSetupFolder, "/", date)
optSetupFolder <- paste0(optSetupFolder, "/", date)
optResultFolder <- paste0(optResultFolder, "/", date)
repResultFolder <- paste0(repResultFolder, "/", date)

for (dir in c(simSetupFolder,
              optSetupFolder,
              optResultFolder,
              repResultFolder)) {
  dir.create(dir,recursive = TRUE)
}

###
varSetupParams <- list(
  # nGen = c(5, 10),
  nGen = c(5),
  plotBudjetPerGen = c(200),#, 600),
  # he = c(0.7, 0.3)
  he = c(0.3)
)

###
nCpus = 2
setup = setupSimulation(dataFile = 'data/fullData.vcf',
                        lchrCm = 100,
                        nQTN = 1000,
                        nGen = 10,
                        nSNP = 3000,
                        mu = 0,
                        he = 0.5,
                        ve = NULL,
                        totalBudget = 1000,
                        plotCost = 1,
                        newIndCost = 1,
                        selectMateInds = selMate_env$selectMate,
                        createModel = genoPred_env$createModel,
                        breedSimOpt = sim_env$breedSimOpt,
                        aggrFun = mean,
                        aggrFunName = 'mean',
                        specName = "bayesOpt",
                        popName = "initialPop",
                        traitName = "trait1",
                        seed = 2021,
                        verbose = TRUE
)
# Constraints / FixedParameters

fixedParams <- setup$fixedParams

###
setupDir <- simSetupFolder
setupsFiles <- list.files(setupDir, full.names = TRUE)
simList <- lapply(setupsFiles, readRDS)
```


```{r}
# test parameters
i = 0.5
iHomo = 0.5
bRep = 0.7
phenoFreq = 5
NewIndSlope = -0.5
SelIntSlope = -0.5
seed = 27012001
nRep = 1
x = c(i, iHomo, bRep, phenoFreq, seed, NewIndSlope, SelIntSlope)


# # create all combination of simSetup and optSetup
# simSetupList <- vector(mode = 'list', length = length(simList) )
# i <- 1
# for (s in seq_along(simList)) {
#   simSetupList[[i]] <- simList[[s]]
#   i <- i + 1
# }

input_list = list(i = x[1],
                  # SelIntSlope = x[7],
                  iHomo = x[2],
                  bRep = x[3],
                  phenoFreq = x[4],
                  seed = x[5],
                  budget = fixedParams$budget,
                  nGen = fixedParams$nGen,
                  initPop = fixedParams$initPop, # a remplir
                  plotCost = fixedParams$plotCost,
                  newIndCost = fixedParams$newIndCost,
                  # NewIndSlope = x[6], #NewIndSlope = r
                  trait = fixedParams$trait,
                  phenotyper = fixedParams$phenotyper, # a remplir
                  createModel = fixedParams$createModel,
                  selectMateInds = fixedParams$selectMateInds,
                  aggrFun = fixedParams$aggrFun,
                  aggrFunName = fixedParams$aggrFunName,
                  verbose = TRUE)






for (k in 1:1) {
  NewIndSlope = runif(n = 1, min = 0, max = 1)
  SelIntSlope = runif(n = 1, min = -1, max = 1)
  cat(paste("\r\n",k,"\r\n NewIndSlope : ", round(NewIndSlope,3), 
            "\r\n SelIntSlope : ",round(SelIntSlope, 3),"\r\n"))
  res = do.call(breedSimOpt, args = c(input_list,
                                      NewIndSlope = NewIndSlope,
                                      SelIntSlope = SelIntSlope
                                      ))
  # cat(k)
  if (is.na(res)) browser()
}

```

```{r}

res <- breedSimOpt(i = x[1],
                   SelIntSlope = x[7],#SelIntSlope = s
                   iHomo = x[2],
                   bRep = x[3],
                   phenoFreq = x[4],
                   seed = x[5],
                   budget = fixedParams$budget,
                   nGen = fixedParams$nGen,
                   initPop = fixedParams$initPop,
                   plotCost = fixedParams$plotCost,
                   newIndCost = fixedParams$newIndCost,
                   NewIndSlope = x[6], #NewIndSlope = r
                   trait = fixedParams$trait,
                   phenotyper = fixedParams$phenotyper, 
                   createModel = fixedParams$createModel,
                   selectMateInds = fixedParams$selectMateInds,
                   aggrFun = fixedParams$aggrFun,
                   aggrFunName = fixedParams$aggrFunName,
                   verbose = TRUE)
```



### Evaluation of Budget and Selection intensity efficacity with changing parameters
```{r}
#Evaluation function
Test_Breeding_camp <- function(i,
                        SelIntSlope,
                        iHomo,
                        bRep,
                        phenoFreq,
                        seed = NA,
                        budget,
                        nGen,
                        initPop,
                        plotCost,
                        newIndCost,
                        NewIndSlope, #NewIndSlope
                        trait,
                        phenotyper,
                        createModel,
                        selectMateInds,
                        aggrFun,
                        aggrFunName,
                        verbose){
  if (!is.na(seed)) {
      set.seed(seed)
    }
  newParams <- list(i = i,
                      iHomo = iHomo,
                      bRep = bRep,
                      phenoFreq = phenoFreq,
                      budget = budget,
                      nGen = nGen,
                      nIndIni = initPop$nInd,
                      plotCost = plotCost,
                      newIndCost = newIndCost,
                      NewIndSlope = NewIndSlope,
                      SelIntSlope = SelIntSlope)
  
    params <- do.call(getSimulParams, newParams)
    
    return(list(
      Budg.Eff = mean(params$eff.budget)/budget,
      i.Eff = mean(params$eff.i)/i,
      nNew = params$nNew,
      nSelected = params$nSelected
    ))
}

```
#
```{r}
nGen = 15
i = 0.5
bRep = 0.3
NewIndSlope = -0.5
res_camp = lapply(0.2*(1:13) - 1.4, function(NewIndSlope){
  Test_Breeding_camp(i = i, # for different values of i
                   iHomo = x[2],
                   bRep = bRep, # for different values of bRep
                   phenoFreq = x[4],
                   seed = x[5],
                   budget = fixedParams$budget,
                   nGen = nGen,#fixedParams$nGen,
                   initPop = fixedParams$initPop,
                   plotCost = fixedParams$plotCost,
                   newIndCost = fixedParams$newIndCost,
                   NewIndSlope = NewIndSlope,  #NewIndSlope
                   trait = fixedParams$trait,
                   phenotyper = fixedParams$phenotyper, 
                   createModel = fixedParams$createModel,
                   selectMateInds = fixedParams$selectMateInds,
                   aggrFun = fixedParams$aggrFun,
                   aggrFunName = fixedParams$aggrFunName,
                   verbose = TRUE)
  })
res_nNew = lapply(res_camp, function(x) x$nNew)
# plot(res_nNew[2:10])

colList = unlist(lapply(1:13,function(k) any(res_nNew[[k]][2:nGen] <= 0)))
colList = ifelse(colList,"red","green")
plot(res_nNew[[1]][2:10], xlim = c(1,nGen),ylim = c(0,50), type = "l", col = colList[1])
for (k in 2:13) { 
  lines(res_nNew[[k]][2:nGen], col=colList[k])
}
# NewIndSlope needs to be bounded between -1 and 1

# res_camp$nNew
# res_camp$nSelected
# plot(res_camp$nNew[2:10], type = "l")
```



# Test for different values of r
```{r}
nGen <- 10
n <- 20

# s_values <- seq(0,1,0.1)
# i0 = 0.1

param_table <- data.frame(i0 = runif(n,0,1), 
                          s = runif(n,-1,1))

plotDta <- data.frame(x = seq(0, nGen, length.out = nGen))
combined_plot <- plot_ly(type = "scatter", mode = "lines", data = plotDta, x = ~x)#, y = ~y1, name = "y1")

# Use lapply to add lines for each y2 value
for (values in 1:n) {
  combined_plot <- combined_plot %>% add_lines(y = slope_i(i0 = param_table$i0[values],
                                                           s = param_table$s[values],
                                                           nGen = nGen,
                                                           mode = 6),
                                               name = paste("s =", round(param_table$s[values], 1)," ; i0 =", round(param_table$i0[values], 1)))
}
combined_plot %>% layout(hovermode = 'compare')
```




# Test with different values of bRep and i
```{r}
list_i = 0.1*(1:10)
list_bRep = 0.1*(1:9)
cross_list_i_bRep = expand.grid(list_i, list_bRep)
colnames(cross_list_i_bRep)= c("i","bRep")
res_eff = lapply(1:nrow(cross_list_i_bRep), function(k){
  Test_Breeding_camp(i = cross_list_i_bRep$i[k], # for different values of i
                   iHomo = x[2],
                   bRep = cross_list_i_bRep$bRep[k], # for different values of bRep
                   phenoFreq = x[4],
                   seed = x[5],
                   budget = fixedParams$budget,
                   nGen = fixedParams$nGen,
                   initPop = fixedParams$initPop,
                   plotCost = fixedParams$plotCost,
                   newIndCost = fixedParams$newIndCost,
                   trait = fixedParams$trait,
                   phenotyper = fixedParams$phenotyper, 
                   createModel = fixedParams$createModel,
                   selectMateInds = fixedParams$selectMateInds,
                   aggrFun = fixedParams$aggrFun,
                   aggrFunName = fixedParams$aggrFunName,
                   verbose = TRUE)
})
res_eff = data.frame(
  Budg.Eff = unlist(lapply(1:length(res_eff),function(k) res_eff[[k]]$Budg.Eff)),
  i.Eff = unlist(lapply(1:length(res_eff),function(k) res_eff[[k]]$i.Eff))
)
res_eff = cbind(cross_list_i_bRep,res_eff)
#create heatmap
library(ggplot2)

ggplot(res_eff, aes(i, bRep, fill = i.Eff)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "blue") +
  labs(title = "Heatmap of i.Eff for Different Values of i and bRep",
       x = "i", y = "bRep", fill = "i.Eff") +
  theme_minimal()

```


### Test on values of i

graphes of nNew with different values of r
```{r}
library(rlang)
library(plotly)
nGen = 10
nTot = 100

# Define a sequence of x values
x <- seq(1,nGen)
r_values = seq(-1,1,0.25)
# result data.frame
res_df = data.frame(x = x,
                    matrix(nrow = length(x), ncol = length(r_values)))


#legend names + associated hash value
legend_names = unlist(lapply(1:length(r_values), 
                    FUN = function(line_param) paste0('r = ',r_values[line_param])))
param_names = unlist(lapply(legend_names, function(u) paste0('hash',hash(u))))
colnames(res_df) = c('x',param_names)
names(legend_names) = param_names

for (line_param in 1:length(r_values)){
  y = (nTot / nGen) * (1 - r_values[line_param] + ((2 * r_values[line_param] * (x - 1)) / (nGen - 1)))
  # print(length(y))
  res_df[param_names[line_param]] = y 
}

# Create figure
colorPalette <- unlist(lapply('red', function(baseColor) colorRampPalette(c(baseColor, "white"))(length(r_values)+1)[1:length(r_values)]))




names(colorPalette) = param_names
fig <- plot_ly(data = res_df, 
               x = ~x, 
               y = as.formula(paste0('~', param_names[1])),
               name = legend_names[param_names[1]], 
               type = 'scatter', mode = 'lines+markers', 
               marker = list(color = colorPalette[param_names[1]]),
               line = list(color = colorPalette[param_names[1]])) %>% 
  plotly::layout(title = "",
         xaxis = list(title = "Generation"),
         yaxis = list (title = "nNew"))

for (name in param_names[-1]) {
  print(as.formula(paste0('~', name)))
  fig = fig %>% add_trace(data = res_df, x = x, y = as.formula(paste0('~', name)),
                          marker = list(color = colorPalette[name]),
                          line = list(color = colorPalette[name]),
                          name=legend_names[name])
}

fig
```

#Beta law

```{r}
library(rlang)
library(plotly)
nGen = 10
# Define a sequence of x values
x <- seq(1,nGen)
i0_Bounds = c(0,1)
s_Bounds = c(-1,1)
# Define different sets of parameters for the beta distribution
# i0_values <- c(1)#seq(0.5,0.75,0.25)
s_values <- seq(-1,1,0.25)

i0_values <- seq(0,1,0.5)
# s_values <- c(1)#seq(-1,1,0.25)
param_df = expand.grid(s=s_values,i0=i0_values)

mode = 5
# result data.frame
res_df = data.frame(x = x,
                    matrix(nrow = length(x), ncol = nrow(param_df)))


#legend names + associated hash value
legend_names = unlist(lapply(1:nrow(param_df), 
                    FUN = function(line_param) paste0('s = ',
                                                      param_df$s[line_param],
                                                      ' ; i0 = ',param_df$i0[line_param],
                                                      collapse='')))

param_names = unlist(lapply(legend_names, function(u) paste0('hash',hash(u))))
colnames(res_df) = c('x',param_names)

names(legend_names) = param_names

for (line_param in 1:nrow(param_df)){
  # y = slope_i(i0 = param_df$i0[line_param], 
  #             s = param_df$s[line_param],
  #             nGen = nGen, 
  #             mode = mode,
  #             i0_Bounds = i0_Bounds, 
  #             s_Bounds = s_Bounds)
  i0 = param_df$i0[line_param]
  s <- param_df$s[line_param]
  print(paste0("s=",s," ; i0=",i0))
  y = s/(1+exp(-i0*(1:nGen-(((1+nGen)/2)))))+(1-s)/2
  # print(length(y))
  res_df[param_names[line_param]] = y 
}

# Create figure
MainColorlist = c('red', 'blue', 'green',"yellow",'magenta')
colorPalette <- unlist(lapply( MainColorlist[1:length(i0_values)], function(baseColor) colorRampPalette(c(baseColor, "white"))(length(s_values)+1)[1:length(s_values)]))




names(colorPalette) = param_names
fig <- plot_ly(data = res_df, 
               x = ~x, 
               y = as.formula(paste0('~', param_names[1])),
               name = legend_names[param_names[1]], 
               type = 'scatter', mode = 'lines+markers',
               marker = list(color = colorPalette[param_names[1]]),
               line = list(color = colorPalette[param_names[1]])) %>% 
  plotly::layout(title = "",
                 xaxis = list(title = "Generation"),
                 yaxis = list (title = "Selection intensity (i)"))

for (name in param_names[-1]) {
  print(as.formula(paste0('~', name)))
  fig = fig %>% add_trace(data = res_df, x = x, y = as.formula(paste0('~', name)),
                          marker = list(color = colorPalette[name]),
                          line = list(color = colorPalette[name]),
                          name=legend_names[name])
}

fig
```
# Opening result files
```{r}
library(dbplyr)
library(rlang)
library(plotly)
#read result files
list_file <- lapply(X = list.files("output-optimization/"), FUN = function(file){
  paste0('output-optimization/',file,"/",list.files(paste0('output-optimization/',file)))
  }) %>%
  unlist %>%
  .[grepl(pattern = "bo", .)]
list_file

resTable <- lapply(list_file,function(file){
                                       data = readRDS(file)
                                       # print(unlist(data$bestPoint))
                                       return(unlist(data$bestPoint))
                                     }) %>%
  do.call(rbind,.)
rownames(resTable) <- paste0("res_",1:nrow(resTable))
resTable
```

#plot NewInd across generation
```{r}
# constants
nGen <- 5
totalBudget <-  200 * nGen
newIndCost <- 1

# plot NewInd across generations

colorPalette = c('red', 'blue', 'green',"yellow",'magenta','gray')
x <- 1:nGen

NewInd_df <- data.frame(x = x,
                    matrix(nrow = length(x), ncol = nrow(resTable)))
legend_names = unlist(lapply(1:nrow(resTable),
                             FUN = function(line_param) paste0('NewIndSlope= ',round(resTable[line_param,'NewIndSlope'],3))))
param_names = unlist(lapply(legend_names, function(u) paste0('hash',hash(u))))
colnames(NewInd_df) = c('x',param_names)
names(legend_names) = param_names


for (line_param in 1:nrow(resTable)){
  nTot <- totalBudget * (1-resTable[line_param,'bRep'])
  print(paste0('nTot = ',nTot))
  y <-  (nTot / nGen) * (1 - resTable[line_param,'NewIndSlope'] + ((2 * resTable[line_param,'NewIndSlope'] * (x - 1)) / (nGen - 1)))
  # print(length(y))
  NewInd_df[param_names[line_param]] = y
}


names(colorPalette) = param_names
fig <- plot_ly(data = NewInd_df,
               x = ~x,
               y = as.formula(paste0('~', param_names[1])),
               name = legend_names[param_names[1]],
               type = 'scatter', mode = 'lines+markers',
               marker = list(color = colorPalette[param_names[1]]),
               line = list(color = colorPalette[param_names[1]])) %>%
  plotly::layout(title = "",
                 xaxis = list(title = "Generation"),
                 yaxis = list (title = "nNew"))

for (name in param_names[-1]) {
  print(as.formula(paste0('~', name)))
  fig = fig %>% add_trace(data = NewInd_df, x = x, y = as.formula(paste0('~', name)),
                          marker = list(color = colorPalette[name]),
                          line = list(color = colorPalette[name]),
                          name=legend_names[name])
}

fig

```


